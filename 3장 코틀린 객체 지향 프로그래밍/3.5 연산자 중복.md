# Recipe 연산자 중복


* 문제

라이브러리에 정의된 클래스와 더불어 +와 *같은 연산자를 사용할 수 있는 클라이언트를 만들고 싶다.


* 해법

코틀린의 연산자 중복 매커니즘을 사용해서 +와 *등의 연산자와 연관된 함수를 구현한다.


* 설명

더하기, 빼기, 곱하기 연산자를 비롯해 많은 연산자가 코틀린에서 함수로 구현되어 있다. 
+, -, * 기호를 사용하면 해당 연산자와 연관된 함수에 처리를 위임한다. 이는 연관 함수를 제공해 클라이언트가 연산자를 사용할 수 있게 한다는 의미다.

자신이 작성하지 않은 클래스에 연산자 관련 함수를 추가하고 싶다면 어떻게 해야 할까? 
확장 함수를 사용해 자신이 작성하지 않은 클래스에도 연산자와 연관된 함수를 추가할 수 있다.
예를 들어 자바에서 아파치 커먼스 Math 라이브러리에서 복소수를 표현하는 Complex 클래스를 생각해보자. 해당 라이브러리를 살펴보면
add, subtract, multiply 같은 메소드가 Complex 클래스에 들어 있다. 코틀린에서 +, -, * 연산자는 plus, minus, times 함수에 대응된다.


# 생각해보기

- 왜 코틀린은 연산자 중복 매커니즘을 별도로 만들었을까?(자바에서 그냥 사용하면되는데)

자바에는 표준 라이브러리와 밀접하게 연관되어 있는 언어 기능이 몇 가지 있는데 대표적으로 for ... in 루프에 java.lang.Iterable을 구현한 객체를 사용할 수 있고,
자원을 사용하는 try문에 java.lang.AutoCloseable을 구현한 객체를 사용할 수 있다.
코틀린에서도 어떤 언어 기능이 정해진 사용자 작성 함수와 연결되는 몇 가지 경우가 있다. 하지만, 코틀린에서 이런 언어 기능이 어떤 타입과 연결되기보다는 특정 함수 이름과 연관된다.
예를 들어 어떤 클래스 안에 plus라는 이름의 특별한 메소도를 정의하면 그 클래스의 인스턴스에 대해 + 연산자를 사용할 수 있다. 이런 식으로 어떤 기능과 미리 정해진 이름의 함수를 연결해주는 기법을
코틀린에서는 관례라고 부른다.

즉, 요약하면 자바는 언어 기능을 타입에 의존하고 코틀린은 관례(함수 이름을 통한)에 의존한다. 코틀린에서 이런 관례를 채택한 이유는 기존 자바 클래스를 코틀린 언어에 적용하기 위함이다.
기존 자바 클래스가 구현하는 인터페이스는 이미 고정돼 있고 코틀린 쪽에서 자바 클래스가 새로운 인터페이스를 구현하게 만들 수는 없다. 반면 확장 함수를 사용하면 기존 클래스에 새로운 메소드를 추가 할 수 있다.
