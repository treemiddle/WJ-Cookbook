# Recipe 2.4 명시적으로 타입 변환하기

* 문제

코틀린은 자동으로 기본 타입을 더 넓은 타입으로 승격하지 않는다. (Int를 Long으로 승격x)


* 해법

명시적으로 변환하려면 toInt(), toLong()등 구체적인 변환 함수를 사용해야 한다.


코틀린에서는 기본 타입을 직접적으로 제공하지 않는다. 바이트코드에서는 아마 해당되는 기본 타입을 생성하겠지지만 개발자가 코드를 직접 작성할 때는 기본 타입이 아닌 클래스를 다룬다는 것에 명심해야 한다.
코틀린에서는 아래와 같은 메소드를 제공한다.


* toByte() : Byte

* toChar(): Char

* toShort(): Short

* toInt(): Int

* toLong(): Long

* toFloat(): Float

* toDouble(): Double


내용이 조금? 부족한 관계로 조금 더 알아보자.

코틀린은 원시 타입과 래퍼 타입을 구분하지 않는다. 자바는 원시 타입(primitive type)의 변수에는 그 값이 직접 들어가지만, 참조 타입(reference type)의 변수에는 메모리상의 객체 위치가 들어간다.

원시 타입의 값을 더 효율적으로 저장하고 여기저기 전달할 수 있다. 하지만 그런 값에 대해 메소드를 호출하거나 컬렉션에 원시 타입 값을 담을 수는 없다. 자바는 참조타입이 필요한 경우 
특별한 래퍼 타입(java.lang.Intenger)등으로 원시 타입 값을 감싸서 사용한다. 따라서 정수의 컬렉션을 정의하려면 Collention<`<Int>`가 아니라 Collection`<Intgeger>`를 사용해야 한다. 
코틀린은 원시 타입과 래퍼 타입을 구분하지 않으므로 항상 같은 타입을 사용한다.
  
```(kotlin)
val i: Int = 1
val list: List<Int> = listOf(1, 2, 3)
``` 
래퍼 타입을 따로 구분하지 않으면 편리하다. 더 나아가 코틀린에서는 숫자 타입 등 원시 타입의 값에 대해 메소드를 호출할 수 있다. 예를 들어 아래 코드는 표준 라이브러리 함수 coerceIn을 사용해 값을 특정 범위로 제한한다.

```(kotlin)
fun showProgress(progress: Int) {
  val percent = progress.coerceInt(0, 100)
  println("percent: $percent")
}
``` 


원시 타입과 참조 타입이 같다면 코틀린이 그들을 항상 객체로 표한하는 걸까? 그렇게 한다면 너무 비효율적이지 않을까? 실제로도 항상 객체로 표현한다면 비효율적이겠지만 코틀린은 그러지 않는다.
실행 시점에 숫자 타입은 가능한 한 가장 효율적인 방식으로 표현된다.
























