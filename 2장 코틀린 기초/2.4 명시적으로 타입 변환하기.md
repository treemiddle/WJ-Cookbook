# Recipe 2.4 명시적으로 타입 변환하기

* 문제

코틀린은 자동으로 기본 타입을 더 넓은 타입으로 승격하지 않는다. (Int를 Long으로 승격x)


* 해법

명시적으로 변환하려면 toInt(), toLong()등 구체적인 변환 함수를 사용해야 한다.


코틀린에서는 기본 타입을 직접적으로 제공하지 않는다. 바이트코드에서는 아마 해당되는 기본 타입을 생성하겠지지만 개발자가 코드를 직접 작성할 때는 기본 타입이 아닌 클래스를 다룬다는 것에 명심해야 한다.
코틀린에서는 아래와 같은 메소드를 제공한다.


* toByte() : Byte

* toChar(): Char

* toShort(): Short

* toInt(): Int

* toLong(): Long

* toFloat(): Float

* toDouble(): Double


내용이 조금? 부족한 관계로 조금 더 알아보자.

코틀린은 원시 타입과 래퍼 타입을 구분하지 않는다. 자바는 원시 타입(primitive type)의 변수에는 그 값이 직접 들어가지만, 참조 타입(reference type)의 변수에는 메모리상의 객체 위치가 들어간다.

원시 타입의 값을 더 효율적으로 저장하고 여기저기 전달할 수 있다. 하지만 그런 값에 대해 메소드를 호출하거나 컬렉션에 원시 타입 값을 담을 수는 없다. 자바는 참조타입이 필요한 경우 
특별한 래퍼 타입(java.lang.Intenger)등으로 원시 타입 값을 감싸서 사용한다. 따라서 정수의 컬렉션을 정의하려면 Collention<`<Int>`가 아니라 Collection`<Intgeger>`를 사용해야 한다. 
코틀린은 원시 타입과 래퍼 타입을 구분하지 않으므로 항상 같은 타입을 사용한다.
  
```(kotlin)
val i: Int = 1
val list: List<Int> = listOf(1, 2, 3)
``` 
래퍼 타입을 따로 구분하지 않으면 편리하다. 더 나아가 코틀린에서는 숫자 타입 등 원시 타입의 값에 대해 메소드를 호출할 수 있다. 예를 들어 아래 코드는 표준 라이브러리 함수 coerceIn을 사용해 값을 특정 범위로 제한한다.

```(kotlin)
fun showProgress(progress: Int) {
  val percent = progress.coerceInt(0, 100)
  println("percent: $percent")
}
``` 


원시 타입과 참조 타입이 같다면 코틀린이 그들을 항상 객체로 표한하는 걸까? 그렇게 한다면 너무 비효율적이지 않을까? 실제로도 항상 객체로 표현한다면 비효율적이겠지만 코틀린은 그러지 않는다.
실행 시점에 숫자 타입은 가능한 한 가장 효율적인 방식으로 표현된다. 대부분의 경우(변수, 프로퍼티, 파라미터, 반환 타입 등) 코틀린의 Int타입은 자바 int타입으로 컴파일이 된다.
이런 컴파일이 불가능한 경우는 컬렉션과 같은 제네릭 클래스를 사용하는 경우뿐이다. 예를들어 Int 타입을 컬렉션의 타입 파라미터로 넘기면 그 컬렉션에는 Int의 래퍼 타입에 해당하는 java.lang.Integer 객체가 들어간다. 

Int와 같은 코틀린 타입에는 널 참조가 들어갈 수 없기 때문에 쉽게 그에 상응하는 자바 원시 타입으로 컴파일할 수 있다. 마찬가지로 반대로 자바 원시 타입의 값은 결코 널이 될 수 없으므로 자바 원시 타입을 코틀린에서 사용할 때도 널이 될 수 없는 타입으로 취급할 수 있다.


null참조를 자바의 참조 타입의 변수에만 대입할 수 있기 때문에 널이 될 수 있는 코틀린 타입은 자바 원시 타입으로 표현할 수 없다. 따라서 코트린에서 널이 될 수 있는 원시 타입을 사용하면 그 타입은 자바의 래퍼 타입으로 컴파일된다. 
널이 될 수 있는 타입을 사용하는 예를 하나 살펴보자.
```(kotlin)
data class Person(
  val name: String,
  val age: Int? = null
) {
  fun isOlderThan(other: Person): Boolean? {
     if (age == null || other.age == null) {
        return null
     }
     
     return age > other.age
  }
}
``` 
널이 될 가능성이 있으므로 Int? 타입의 두 값을 직접 비교할 수는 없다. 먼저 두 값이 모두 널이 아닌지 검사해야한다. 컴파일러는 널 검사를 마친 다음에야 두 값을 일반적인 값처럼 다루게 허용한다. 
Person클래스에 선언된 age 프로퍼티의 값은 java.lang.Interger로 저장된다.
앞에서 이야기한 대로 제네릭 클래스의 경우 래퍼 타입을 사용한다. 
```(kotlin)
val list = listOf(1, 2, 3)
``` 
위에 있는 코드는 null 값이나 널이 될 수 있는 타입을 전혀 사용하지 않았지만 만들어지는 리스트는 래퍼인 Integer 타입으로 이뤄진 리스트이다.
이렇게 컴파일 하는 이유는 JVM에서 제네릭을 구현하는 방법 때문이다. JVM은 타입 인자로 원시 타입을 허용하지 않는다. 따라서 자바나 코틀린 모두에서 제네릭 클래스는 항상 박스 타입을 사용해야 한다.


# 정리

* 코틀린에서 기본 타입을 변환할 때 명시적으로 변환해야 한다.



# 생각해보기


1. 왜 코틀린은 자바와 다르게 원시타입, 참조타입을 나눴을까?


















